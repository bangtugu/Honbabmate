이번 프로젝트에서는 spring을 통해 백엔드를 구현하기로 하였다.

1학기 과정에서는 백엔드 구현에 파이썬의 django만을 사용해봤으므로, java와 spring은 새로 배워야 했다.

django를 배우기 전 파이썬을 토대로 쌓았듯 이번에도 spring을 배우기 위해 java를 먼저 익히기로 하였다.



## JAVA

#### 개인적으로 인상적이었던 JAVA의 특징

1. 모든 운영체제에서 실행 가능

   자바로 작성된 프로그램은 모든 운영체제에서 수정 없이 바로 실행할 수 있다.

   이것이 가능한 이유는 자바의 컴파일러가 코드를 직접적인 CPU 명령어로 변환하는것이 아닌, JVM이라는 자바 바이트코드 실행기가 이해하는 자바 바이트코드로 변환시키기 때문에 JVM만 있다면 어떤 운영체제에서도 같은 코드로 같은 기능을 수행해낼 수 있다.

2. 메모리 자동 정리

   힙 메모리에 존재하는 객체 중 어느 변수에도 참조되지 않는 객체가 메모리에서 자동으로 제거된다.

3. package 밑에 class를 생성하여 코드 작성

   백지상태의 py파일 하나를 생성해서 바로 코드를 작성하는 파이썬과 다르게 프로젝트를 생성하고 package를 생성하고 그 밑에 또 class를 생성하여 비로소 코드를 작성한다.

   다른 언어도 프로젝트를 생성해서 그 밑에 소스코드를 여러개 생성하는 것 같아 독립된 py파일을 생성하는 파이썬이 특이한 경우일 수도 있겠지만, 파이썬을 기준으로 작성했다.



#### 변수

* 파이썬과 달리 변수를 선언해줘야 함.

  ```python
  # 파이썬
  a = 10
  b = 0.1
  
  print(a)
  print(b)
  
  # 결과
  # 10
  # 0.1
  ```

  ```java
  // package, class, method 생략
  
  int a = 10; //명령어 끝에 ;를 붙여줘야 함.
  double b = 0.1;
  
  System.out.println(a);
  System.out.println(b);
  
  // 결과
  // 10
  // 0.1
  ```

##### 기본 타입

* 정수 타입

  byte     1byte

  short   2byte

  char     2byte (0~65535) (유니코드)

  int        4byte

  long     8byte

* 실수 타입

  float        4byte (32bit)

  double   8byte (64bit)

* 논리 타입

  boolean - True/False

* 문자열은 기본 타입이 아니다. 클래스 타입이다.



##### 타입 변환

* 작은 타입에서 큰 타입으로 변환하는 경우 (byte -> short, int / float -> double) 자동으로 타입이 변환된다.

* 정수 타입에서 실수 타입으로 변환하는 경우에도 자동으로 변환된다.

* 큰 타입에서 작은 타입으로는 자동으로 변환되지 않고 강제로 변환시켜줘야 하며, 값에 손실이 있을 수 있다.

  ```java
  byte a = 3;
  int b = a;
  // 자동으로 변환됨
  
  int a = 150;
  long b = a;
  // 자동으로 변환됨
  
  int a = 150;
  byte b = a;
  // 컴파일 에러
  
  int a = 150;
  byte b = (int) a;
  // 강제 변환
  
  double a = 3.11;
  int b = (int) a;
  // 강제 변환. 소수점 이하 자리의 값을 손실한다.
  ```



#### 연산자와 연산식

* 문자열과 숫자를 더할(+) 경우, 문자열로 변환되어 합쳐진다.

  ```java
  System.out.println('2' + 3 + 4);
  // 출력 결과 : 234
  
  System.out.println(2 + 3 + '4');
  // 출력 결과 : 54
  ```

* 단항연산자가 앞에 있는지 뒤에 있는지에 따라 연산의 순서가 바뀜.

  ```java
  int a = 1;
  int b = 10;
  
  int c = ++a + b;
  // c = 12
  int c = a++ + b;
  // c = 11 (a+b가 먼저 수행되고 나서 a에 값이 증가됨.)
  ```

외에는 파이썬과 큰 차이는 없는 것 같다.



#### 조건문과 반복문

* if, for, while의 경우 약간의 문법 차이 외엔 파이썬과 동일함.

* switch문

  ```java
  String number = "";
  
  switch(a) {
      case 0: number = "zero"
          break;
      case 1: number = "one"
          break;
      case 2: number = "two"
          break;
      case 3: number = "three"
          break;
      case 4: number = "four"
          break;
      case 5: number = "five"
          break;
      case 6: number = "six"
          break;
      case 7: number = "seven"
          break;
      case 8: number = "eight"
          break;
      case 9: number = "nine"
          break;
      default: number = "한자리 수가 아님"
          break;
  }
  // if/else 문으로 작성할 경우 조건마다 조건문을 추가해야함. switch문으로 더 간단하게 작성할 수 있다.
  ```

* do-while문

  ```java
  do {
      // 반복할 코드
  } while (/* 조건 */);
  // while문은 조건에 맞지 않으면 반복문에 진입이 안되지만,
  // do-while문은 반복문이 최소 한번은 진행되고 더 반복할지 결정하게 된다.
  ```

  





똑같은 변수, 연산, 조건, 반복인데 생각보다 다른점이 많아서 공부하면서 신기하고 재밌다.

당장은 다른 언어들과도 일맥상통하는 내용들이라 이해하기 수월한 것 같지만, 알고리즘을 짠다거나 자바 기반 라이브러리를 사용하는 등 더 심화된 내용을 접한다면 얼마나 새롭고 어려울지 살짝은 막막하다. 





#### 배열

* 배열 또한 직접 선언해주어야 한다. (숫자형 배열, 문자형 배열 등 타입을 정해야함.)

  ```java
  // 정수형 배열
  int 정수형배열[] = {1, 2, 3, 4, 5};
  int[] 정수형배열 = {1, 2, 3, 4, 5};
  
  // 문자형 배열
  String 문자형배열[] = {'가', '나', '다', '라', '마'};
  String[] 문자형배열 = {'가', '나', '다', '라', '마'};
  
  // 문자형배열[2], 정수형배열[3] 이런식으로 파이썬과 같이 인덱스로 값 호출 가능
  // 인덱스는 동일하게 0부터 시작
  ```

* 배열 또한 변수가 힙 메모리의 배열 객체를 참조한다.

* 자바의 배열은 선언할 때 길이를 정해주어야 하며, 길이를 늘리거나 줄일 수 없다. 늘리거나 줄여야 할 경우, 새로 선언한 후 값을 복사해 넣어줘야 한다.

  ```java
  int 작은정수형배열[] = {1, 2, 3, 4, 5};
  
  int 큰정수형배열[] = new int[10];
  
  // for문을 이용한 복사
  for(int i=0; i<작은정수형배열.length; i++) {
      큰정수형배열[i] = 작은정수형배열[i];
  }
  
  // arraycopy 메소드를 이용한 복사
  // System.arraycopy(기존배열, int 기존배열의_시작_인덱스, 새로운배열, int 새로운배열의_시작_인덱스, int 복사할_갯수);
  System.arraycopy(작은정수형배열, 0, 큰정수형배열, 0, 작은정수형배열.length);
  
  ```

##### 배열, 컬렉션에서의 향상된 for문

* 컬렉션은 아직 어떤건지 모르겠지만, 배열에 대해서 파이썬 (for num in 리스트:)과 같이 간단하고 효율적인 for문을 사용할 수 있다.

  ```java
  int 작은정수형배열[] = {1, 2, 3, 4, 5};
  
  //for   num in list  파이썬 문법과 일맥상통
  for(int num : 작은정수형배열) {
      System.out.println(num);
  }
  
  //결과
  //1
  //2
  //3
  //4
  //5
  ```

  

#### 객체 지향 프로그래밍

* 객체는 독립적으로 존재

  * 각 객체마다 속성을 지닌다. (필드)
  * 각 객체마다 동작을 가진다. (메소드)

* 각 객체는 다른 객체와 상호작용을 통해 서로의 기능을 이용할 수 있다.

  * A 객체의 메소드가 B 객체의 B-1 메소드를 호출하는 기능, B-1메소드는 입력값을 토대로 동작을 수행하고 값을 리턴하는 등.

  ```
  A 객체 {
  	int 리턴값 = B객체.메소드B-1(입력값1, 입력값2, ...)
  }
  
  B 객체 {
  	메소드B-1 {
  		입력값 받아서 처리 후 리턴
  	}
  }
  ```

  ```java
  int result = Calculator.add(10, 20);
  // 사람이 Calculator 객체에 10, 20을 입력값으로 하는 add 메소드 호출
  // Calculator는 30을 정수형 변수 result에 저장한다.
  ```

* 객체는 개별적으로 사용 가능하나 대부분 다른 객체와 관계를 맺고 있음.

  * 상속 관계 : ex) 자동차는 기계의 한 종류
  * 사용 관계 : ex) 사람은 자동차를 사용
  * 집합 관계 : ex) 엔진, 타이어 등을 자동차의 부품



##### 객체와 클래스

* 객체를 만드는 설계도가 바로 클래스이다.
* 해당 클래스로 만들어진 객체 = 클래스의 `인스턴스`
* 클래스로 객체를 만드는 과정을 `인스턴스화` 라고 함.



##### 클래스 선언

* 클래스 이름.java로 소스 파일 생성 (ex: Class_No1.java)

  ```java
  public class Class_No1 {
      
  }
  ```

* 일반적으로 하나의 소스코드에 하나의 클래스를 작성하나, 2개 이상 선언도 가능.

  ```java
  public class Class_No1 {
      
  }
  
  class Class_No1_1 {
      
  }
  
  // public 접근 제한자는 파일 이름과 동일한 클래스에만 붙일 수 있다. 접근 제한자의 의미는 추후 학습. 가급적 소스 파일 하나당 동일한 이름의 클래스 하나만 선언.
  ```

* 2개 이상의 클래스가 작성된 소스파일을 컴파일하면, 바이트 코드는 클래스 갯수만큼 생성됨.

  결국 소스파일은 클래스 선언을 담는 저장 단위일 뿐, 클래스 자체는 생성된 바이트코드임.

  

##### 객체 생성

* 클래스 생성

  ```java
  new Class_No1();
  
  // new는 클래스로부터 새로운 객체를 생성하는 연산자.
  ```

* 객체를 생성시키더라도 메모리에서 위치를 찾을 수 없으면 사용할 수 없음.

  생성된 객체를 참조하는 변수를 생성하여 객체 사용 가능.

  ```java
  Class_No1 객체1 = new Class_No1();
  ```

   

##### 클래스의 두 가지 용도

* 클래스는 라이브러리용, 실행용 클래스 두가지로 구분된다.
  * 라이브러리용 : 다른 클래스에서 이용할 목적으로 설계된 클래스
  * 실행용 : 프로그램 실행 진입점 main() 메소드 제공
* 프로그램 전체의 n개의 클래스 중 n-1개의 클래스는 라이브러리용이고 1개의 클래스만 실행용.



##### 클래스의 구성 요소

* 필드 : 객체의 고유 데이터, 정보 저장공간

  * 필드 선언은 클래스 중괄호{} 내부 어디에서나 가능하다. (단 생성자, 메소드 중괄호 내부 제외. 로컬 변수가 돼버림.)
  * 초기값을 따로 설정하지 않으면 기본 초기값으로 설정된다. (ex: int=0, String=null)

* 생성자 : 객체 생성시 초기화 담당

  * 객체 생성 시 다양한 값으로 필드를 초기화한 객체 생성 가능
  * 각 클래스는 하나 이상의 생성자를 가질 수 있음.
  * 따로 생성자를 작성하지 않으면, 기본 생성자(중괄호 내부가 비어있음)가 바이트 코드에 자동으로 추가됨.
  * 하나라도 생성자를 작성하면 기본 생성자는 추가되지 않음.
  * 생성자 오버로딩 
    * 매개 변수의 종류가 다른 여러 생성자를 선언하는것
    * 외부에서 제공되는 데이터의 상태에 따라 객체를 생성할 수 있게 함.
    * 단 매개변수의 타입, 개수, 선언된 순서가 똑같을 경우 오버로딩이 아니다.
  * this를 통해 같은 클래스의 생성자를 호출할 수도 있음. (중복코드 제거)

* 메소드 : 객체의 동작

  * 리턴타입 메소드이름 ( 매개변수 ) { 실행코드 } 요소를 가진다.
  * 리턴타입
    * 리턴값이 없는경우 void,
    * 있는 경우 int, String, double 등 선언해줘야함.
  * 메소드에서 return은 파이썬 함수에서의 return과 같이 메소드를 바로 중지시킬 수 있다.

  ```java
  public class Class_No1() {
      
      //필드
      //필드_고유 데이터
      int number = 0;
      String name = '클래스No1';
      
      
      //생성자
      Class_No1() {    }
      //생성자를 여러개 선언하여 생성자 오버로딩
      Class_No1(int number, String name) {
          // this를 붙여주어 매개 변수가 아닌 객체 자신 참조
          this.number = number;
          this.name = name;
      }
      // 객체생성시 Class_No1 newclass = new Class_No1(5, '클래스No1_1'); 와 같은 방식으로 매개값을 넣어주는 경우
      
      
      //다른 생성자 호출하여 중복 코드 줄이기
      //this를 통해 4개의 매개변수를 가지는 생성자를 다시 호출하는 방식
      A 매개변수, B,C,D는 기본값인 생성자 (A) {
          this(A, B기본값, C기본값, D기본값)
      }
      A,B 매개변수, C, D는 기본값인 생성자 (A, B) {
          this(A, B, C기본값, D기본값)
      }
      A,B,C,D 모두 매개변수인 생성자 (A, B, C, D) {
          this.A = A;
          this.B = B;
          this.C = C;
          this.D = D;
      }
      
      
      //필드_상태 데이터
      boolean is_active = true;
      
      
      //메소드
      void methodName(매개변수선언) {
          실행블록
      }
      
      
      //필드_부품 클래스
      Class_part1 classpart1;
      Class_part2 classpart2;
  }
  ```



##### 인스턴스 / 정적 멤버

* 클래스의 인스턴스마다 동일한 값을 가지는 필드의 경우 객체마다 데이터를 가지게 하면 객체만큼 메모리를 더 사용해야한다.

* 그러므로 동일한 값을 가지는 필드, 메소드를 정적(static) 멤버로써 객체에 따로 저장하지 않고 클래스 단에 위치시키면 메모리상에서 더 효율적이다.

  ```java
  public class 클래스 {
      //정적 필드
      static 타입 필드 [=초기값];
      
      //정적 메소드
      static 리턴타입 메소드(매개변수선언) {
          
      }
  }
  ```

* 정적 멤버들의 경우 객체 생성 없이도 클래스가 메모리로 로딩되면 클래스.연산자로 바로 사용이 가능하다.

  ```java
  타입 변수이름 = 클래스.메소드(매개변수);
  
  // 인스턴스 멤버의 경우
  // 클래스 클래스이름 = new 클래스();
  // 타입 변수이름 = 클래스이름.메소드(매개변수);
  ```

* 정적 멤버더라도 객체 참조 변수로도 접근 가능. 하지만 정적 멤버는 클래스 이름으로 접근하는것을 권장.

* 정적 메소드를 클래스.연산자로 바로 사용할때에는 인스턴스 필드를 사용할 수 없다. 인스턴스 필드, 메소드를 사용하려면 객체를 생성하고 사용해야함.



##### 싱글톤 객체

* 가끔 전체 프로그램에서 클래스 하나로 단 하나만의 객체를 만들도록 제한해야 하는 경우가 있다.

  이러한 객체를 싱글톤(Singleton)이라고 함.

* 싱글톤이 되려면 외부에서 new 연산자로 해당 클래스의 새로운 객체를 만드는것을 막아야함.

  * 생성자 앞에 `private` 접근 제한자 붙여주기

  ```java
  public class Singleton {
      //정적 필드를 통해 자신 객체를 생성해 초기화
      private static Unique_Singleton = new Singleton();
      
      //생성자
      private Singleton() {}
  	
      //정적 메소드
      static Singleton getInstance() {
          return Unique_Singleton;
      }
  }
  ```

* 외부에서 객체를 얻는 (변수에 참조시키는) 유일한 방법은 getInstance() 메소드를 호출하는 방법 뿐이다.

  ```java
  Singleton class_1 = Singleton.getInstance();
  Singleton class_2 = Singleton.getInstance();
  Singleton class_3 = Singleton.getInstance();
  
  // 해당 메소드는 정적 필드를 통해 생성된 단 하나만의 객체를 반환하므로 3개의 변수 모두 유일한 하나의 객체를 참조한다.
  ```

  

##### final 필드

* final 필드에 선언된 초기값은 프로그램 실행 도중 수정할 수 없다.

  ```java
  final 타입 필드;
  final 타입 필드 = 초기값;
  ```

* 사용예

  * 사용자의 주민번호 (주민번호는 객체(사람)마다 고유하므로 변경할 수 없다.)

  * 상수

    * 상수는 객체마다 저장할 필요 없는 불변의 값이므로, 클래스에 static final로써 선언한다.
    * 이름규칙 : 전체 대문자, 단어 연결시 언더바(_)

    ```java
    static final double PI = 3.14159;
    static final double EARTH_RADIUS = 6400;
    static final double EARTH_AREA = 4 * PI * EARTH_RADIUS * EARTH_RADIUS;
    ```

    

##### 패키지와 접근 제한자

* 패키지의 물리적 형태 : 파일 시스템의 폴더

* 물리적 파일 시스템 뿐만 아니라 클래스를 유일하게 만들어주는 식별자 역할 또한 수행

  * 클래스 이름이 같더라도 패키지가 다르면 다른 클래스로 인식

* 패키지.클래스 형식으로 클래스의 풀네임 지정

  * 패키지가 중첩되어있다면 상위패키지.하위패키지.클래스 형식

* 클래스 작성 시 패키지 선언

  * 클래스를 작성할 때 어떤 패키지에 속할것인지 선언

    ```java
    // toppackage 패키지 밑의 bottompackage 패키지에 속하는 MyClass클래스 선언
    package toppackage.bottompackage;
    
    public class MyClass {}
    
    // MyClass는 toppackage.bottompackage에 소속되어 있기 때문에, 클래스만 복사해서 이동시키면 클래스를 사용할 수 없게 됨.
    // 클래스를 이동시키고자 한다면 패키지 전체를 이동시켜야 함.
    ```



##### import 문

* 사용하고자 하는 클래스가 다른 패키지에 소속되어 있다면 import문으로 해당 패키지의 클래스를 가져와 사용한다는 코드를 작성해주어야 함.

  ```java
  import toppackage.bottompackage.MyClass; // 클래스 하나만 import
  import toppackage.bottompackage.*; //해당 패키지의 모든 클래스 import
  
  import toppackage.*; // 상위 패키지를 import 한다고 해서 하위 패키지까지 import 되는것은 아님.
  import toppackage.bottompackage.*; // 두 패키지 모두 import 해줘야 두 패키지의 클래스를 모두 사용할 수 있음.
  ```

* 만약 import된 여러 패키지 하에 중복된 이름을 가지는 클래스들을 사용하려는 경우, 패키지까지 전체 이름을 기술해야 한다.

  * 클래스 이름만을 기술하는 경우 어떤 패키지의 클래스를 사용하려 하는지 선택이 되지 않았기 때문.
  * 중복되지 않는 고유한 클래스 이름일 경우 클래스 이름만으로 사용이 가능하다.



##### 접근제한자

* public : 외부 클래스가 자유롭게 사용 가능
* protected : 같은 패키지, 자식 클래스에서 사용 가능
* private : 외부에서 사용할 수 없음
* defaut : 같은 패키지의 클래스들에서만 사용 가능
  * 위의 3가지가 적용되지 않으면 적용됨. 

* 클래스, 생성자, 필드, 메소드 모두 접근 제한자 설정 가능



##### Setter, Getter

* 객체의 필드를 외부에서 직접적으로 접근하게 한다면, 객체의 무결성을 해치거나 적절하게 가공되지 않은 데이터를 출력하게 된다.

* Setter, Getter 메소드를 통해 이러한 허점을 막고 중간에서 입력 데이터 유효성 검사, 출력 데이터 가공을 진행할 수 있다.

  ```java
  객체.필드 = 변경값;
  // 이런 직접적인 접근 대신
  
  void setvalue(double value) {
      if (value < 0) {
          this.필드 = 0; // 변경값이 음수로 내려가지 못하도록
          return;       // 메소드 즉시 종료
      }
      this.필드 = value;
      return;
  }
  
  
  // 자동차의 속도를 마일에서 km단위로 (화씨온도에서 섭씨온도로) 환선해서 리턴해주는 메소드
  double getSpeed() {
      double km = speed*1.6; // speed에 마일 단위의 속도가 기록
      return km;             // 외부로 값 반환
  }
  ```

* 필드를 private로 접근제한하여 내부 메소드에 의해서만 접근 가능하도록 보호하고, Getter/Setter 메소드를 public으로 선언하여 필드값을 안전하게 변경/사용 가능







#### 상속

* 자식 클래스에서 상속받을 부모 클래스 결정 ( 하나만 상속받기 가능 )

  ```java
  class 자식클래스이름 extends 부모클래스이름 {
      //필드
      //생성자  부모클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 
      //메소드  제외된다.
  }
  ```

* 자식 클래스 객체를 생성하면, 상속받을 부모 클래스 객체가 먼저 생성되고 자식 객체가 생성된다.

  ```java
  public 자식클래스이름 () {
      super(); // 부모클래스의 기본생성자를 호출하는 코드. 작성하지 않아도 컴파일러에서 자동으로 생성함
  }
  public 자식클래스이름 ( 매개변수선언, ) {
      super( 매개값, ) // 명시적으로 부모 클래스 생성자를 호출하고싶다면 매개값을 넣어주면 됨. 부모클래스에 기본생성자가 없고 매개변수가 있는 생성자만 존재한다면, 필수적으로 호출해야 함.
  }
  ```



##### 메소드 재정의

* 부모 클래스의 어떤 메소드는 자식 클래스에 적합하지 않을 수 있다.

  이러한 경우 상속된 일부 메소드를 자식 클래스에서 수정해서 사용해야 함.

  규칙

  * 부모의 메소드와 동일한 시그니쳐(리턴 타입, 메소드 이름, 매개 변수 목록)를 가져야 함.
  * 접근 제한을 더 강하게 재정의할 수 없음. (느슨하게는 가능)
  * 새로운 예외(Exception)를 throws할 수 없음 (예외는 후에 학습)
  * 메소드가 재정의되면, 자식 객체에서 메소드를 호출하면 부모 객체의 메소드 대신 자식 객체의 재정의된 메소드가 호출됨.

  ```java
  class Parent {
      void method1() {    }
      void method2() {    }
  }
  
  class Child {
      // Override는 생략해도 되나, 붙여주면 컴파일러에서 이 메소드가 재정의된 것인지 파악할 수 있음.
      // 그로인해 예를들어, 부모 클래스의 메소드 이름이 method2인데 자식 클래스에서 메소드 재정의를 metho2로 오타를 내면, Override를 붙여줬다면 컴파일 에러가 발생해 개발자에게 알려주지만, 붙여주지 않았다면 에러 없이 자식 클래스의 새로운 메소드가 선언됨.
      @Override
      void method2() {    } // 재정의
      void method3() {    }
  }
  ```

* 부모 메소드 호출

  ```java
  super.부모메소드() // 재정의되어 숨겨진 부모 메소드 호출
  ```

  

#### final 클래스와 메소드

* final 필드는 초기값을 변경할 수 없다는 의미이지만,
* final 클래스는 더이상 이 클래스를 상속받을수 없다는 의미 즉 부모 클래스가 될 수 없다는 의미이다.
* final 메소드는 재정의할 수 없다는 의미 즉 자식 클래스에서 이 메소드를 재정의할 수 없다는 의미이다.



#### 클래스의 타입 변환

* 자식 클래스에서 부모 클래스로 자동 타입 변환 가능

  ```java
  Child child = new Child();
  Parent parent = child;
  child == parent; // 결과 = true
  // 재정의된 자식 클래스의 메소드 이외에는 모두 부모 클래스에 선언된 필드, 메소드에만 접근 가능
  ```

* 부모 클래스로 자동 타입 변환된 자식 클래스를 다시 자식 클래스로 강제 타입 변환 가능

  ```java
  Parent parent = new Child();  // 자동 변환
  Child child = (Child) parent; // 강제 변환
  ```

  

#### 인터페이스

* 인터페이스 - 개발 코드와 객체가 서로 통신하는 접점 역할

  * 개발코드의 인터페이스 메소드 호출 -> 인터페이스의 객체 메소드 호출

* 인터페이스를 사용하면 코드 수정 없이 사용하는 객체를 변경할 수 있어 실행 내용과 리턴값을 다양화할 수 있다.

* 인터페이스의 선언

  ```java
  interface 인터페이스이름 {    }
  // 클래스 선언에서 class 대신 interface 사용하는것과 같음
  ```

* 클래스는 필드, 생성자, 메소드를 가지지만 인터페이스는 상수, 추상 메소드만을 구성 멤버로 가짐.

  ```java
  interface 인터페이스이름 {
      //상수
      타입 상수이름 = 값;
      //추상 메소드
      타입 메소드이름(매개변수, ... );
  }
  ```



##### 상수와 추상 메소드

* 인터페이스는 데이터를 저장하는 인스턴스 또는 정적 필드를 선언할 수 없다. 하지만 상수 필드와 추상 메소드는 선언이 가능하다.

  ```java
  [public static final] 타입 상수이름 = 값;  // 상수 선언
  [public abstract] 리턴타입 메소드이름(매개변수, ... );
  // [] 내부 코드 생략하여도 컴파일 과정에서 자동으로 추가됨.
  ```

* 추상 메소드

  * 인터페이스를 통해 호출된 메소드는 최종적으로 객체에서 실행.
  * 인터페이스의 메소드는 실행 블록이 없는 `추상 메소드` 로 선언



##### 구현 객체, 클래스

* 객체는 추상 메소드와 동일한 메소드이름, 매개타입, 리턴타입을 가진 실체 메소드를 가지고 있어야 한다.

* 이러한 객체를 인터페이스의 `구현 객체` , `구현 객체`를 생성하는 클래스를 `구현 클래스` 라고 한다. 

  ```java
  public class 구현클래스이름 implements 인터페이스이름 {
      // 인터페이스 타입으로 사용될 수 있음을 알려주기 위해 implements 키워드 추가
      // 인터페이스에 선언된 추상 메소드의 실체 메소드 선언
  }
  ```

  * 인터페이스의 추상 메소드는 기본적으로 public 접근 제한을 갖기 때문에, 실체 메소드를 public보다 더 낮은 접근 제한으로 작성할 수 없다.

* 인터페이스로 구현 객체를 사용하기 위해 인터페이스 변수를 선언하고 구현 객체를 대입해야 한다.

  ```java
  인터페이스이름 변수이름;
  변수이름 = 구현객체;
  
  // or
  
  인터페이스이름 변수이름 = 구현객체;
  ```

* 다중 인터페이스를 구현할 경우, 구현 클래스는 모든 인터페이스의 추상 메소드에 맞는 실체 메소드를 작성해야 한다.

  ```java
  public class 구현클래스이름 implements 인터페이스1, 인터페이스2, ... {
      // 인터페이스1에 선언된 추상 메소드의 실체 메소드
      // 인터페이스2에 선언된 추상 메소드의 실체 메소드
      // 인터페이스3에 선언...
      // ...
  }
  ```



